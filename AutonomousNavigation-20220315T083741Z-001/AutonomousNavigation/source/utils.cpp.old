#include "utils.h"
#include "fm_planner/utils.hpp"

namespace utils 
{

  using std::ifstream;
  using std::cout;
  using std::cerr;
  using std::endl;
  using std::string;


  bool loadPath(string filename, G2lib::ClothoidList & cl)
  {
    cl = G2lib::ClothoidList();

    ifstream input(filename);
    if (!input.is_open()) return false;

    while (!input.eof())
    {
      double x, y, th, k, dk, L;
      if (!(input >> x >> y >> th >> k >> dk >> L))
      {
        if (input.eof())
          break;
        return false;
      }
      G2lib::ClothoidCurve cc(x, y, th, k, dk, L);
      cl.push_back(cc);
    }
    return true;
  }

  bool loadGoal(string filename, State2d & goal) {
    ifstream input(filename);
    if (!input.is_open()) return false;
    return !(input >> goal.x >> goal.y >> goal.theta).fail();
  }

  bool getObstacles(std::string const & filename, std::vector<Obstacle> & map)
  {
    map.clear();

    ifstream input(filename);
    if (!input.is_open())
    {
      cerr << "Error opening file " << filename << endl;
      return false;
    }

    try 
    {
      std::string str((std::istreambuf_iterator<char>(input)), std::istreambuf_iterator<char>());
      json jdata = json::parse(str);
      return getObstacles(jdata, map);
    } 
    catch (...)
    {}

    input.clear();                 // clear fail and eof bits
    input.seekg(0, std::ios::beg); // back to the start!
    
    const string PARSE_ERROR_MSG = "Error while parsing map file";

    while (!input.eof())
    {
      int size;
      if (!(input >> size))
      {
        if (input.eof())
          break;
        cerr << PARSE_ERROR_MSG << endl;
        return false;
      }

      Obstacle curr;
      for (int i=0; i<size; ++i)
      {
        double x, y;
        if (!(input >> x >> y))
        {
          cerr << PARSE_ERROR_MSG << endl;
          return false;
        }

        curr.push_back({x, y});
      }

      if (curr.back()!=curr.front())
      {
        curr.push_back(curr.front());
      }

      map.push_back(curr);
    }
    
    return true;
  }

  bool getObstacles(json const & jdata, std::vector<Obstacle>& obstacles)
  {
    obstacles.clear();

    double x, y;
    
    try 
    {
      json j_arr_boundaries = jdata.at("boundaries");
      json j_arr_obstacles  = jdata.at("obstacles");
    
      Obstacle curr;
      for (json::iterator it = j_arr_boundaries.begin(); it != j_arr_boundaries.end(); ++it) 
      {      
        x = (*it).at("x");
        y = (*it).at("y"); 
        curr.push_back({x, y});
      }
      if (curr.back() != curr.front())
        curr.push_back(curr.front());
      obstacles.push_back(curr);

      for (json::iterator it = j_arr_obstacles.begin(); it != j_arr_obstacles.end(); ++it) 
      {
        Obstacle curr;     

        json tmp_obstacles = (*it).at("data");
        for (json::iterator itt = tmp_obstacles.begin(); itt != tmp_obstacles.end(); ++itt) 
        {
          curr.push_back({(*itt).at("x"), (*itt).at("y")});
        }
        if (curr.back() != curr.front())
          curr.push_back(curr.front());
        obstacles.push_back(curr);
      }
    } 
    catch (std::exception & ex)
    {
      std::cerr << ex.what() << std::endl;
      return false;
    }

    return true;
  }

  void extractInliers(const cv::Mat & image, std::vector<cv::Point> & validPoints, double xm, double ym, double xM, double yM, double distFromLine) {
      double theta = atan2(yM-ym, xM-xm);
      theta = (theta / pi) * 180;

      cv::Point2f centre = cv::Point2f((xm+xM)/2,
                                         ((ym+yM)/2));



        cv::Size2f sides( sqrt((xM-xm)*(xM-xm)+(yM-ym)*(yM-ym)),1+2*distFromLine );

        cv::RotatedRect rRect = cv::RotatedRect(centre, sides, theta);


        // The next lines are to extract the inliers
        cv::Point2f vertices2f[4];
        cv::Point vertices[4];
        rRect.points(vertices2f);
        for(int i = 0; i < 4; ++i){
          vertices[i] = vertices2f[i];
        }
        cv::Mat mask (image.size(), image.type(), cv::Scalar::all(0));
        cv::fillConvexPoly(mask,
                           vertices,
                           4,
                           cv::Scalar::all(255));

        cv::Mat work = mask & image;
        validPoints.clear();
        cv::findNonZero( work, validPoints);

    }

}

