#ifndef UTILS_H
#define UTILS_H

#include <vector>
#include <string>
#include <fstream>
#include <iostream>

#include "opencv2/imgproc.hpp"

#include <opencv2/core.hpp>

//#include "util/exc.hpp"
#include <cmath>
#include <valarray>
#include <numeric>
#include <robotstatus.h>

#include "ClothoidList.hh"
#include "fm_planner/utils.hpp"

#include "json.hpp"

static const int CAM_WIDTH_SMALL  = 800;
static const int CAM_HEIGHT_SMALL = CAM_WIDTH_SMALL*9/16;
static const int CAM_FPS_SMALL    = 30;
static bool ROBOT_CONNECTED = true;

enum class PALLET_FORKING_PROCESSOR_STATE{
    WAITING_START,
    PALLET_SEARCHING,
    PALLET_ALIGNING,
    PALLET_LOST,
    FOLLOWING_THE_PATH,
    ADJUSTING_MANEUVRE,
    FORKING,
    FORKED,
    UNFORKING,
    GOING_AWAY,
    STOPPED,
    LIFTING,
    PALLET_FORKING_FALIED,
    PROCEDURECOMPLETED,
    PALLET_IMPOSSIBLE_TO_BE_FORKED
};

class Pallet{
public:
    double x;
    double y;
    double rho;

    Pallet(){
        x=0;
        y=0;
        rho=0;
    }

    Pallet(Pallet* p){
        x=p->x;
        y=p->y;
        rho=p->rho;
    }


    Pallet(double x, double y, double rho){
        this->x = x;
        this->y = y;
        this->rho = rho;
    }

    Pallet(const Pallet & p){
        x = p.x;
        y = p.y;
        rho = p.rho;
    }
};

namespace utils 
{

  using json = nlohmann::json;

  struct Point2D
  {
    double x, y;
    friend bool operator==(Point2D const & p1, Point2D const & p2) { return p1.x==p2.x && p1.y==p2.y; }
    friend bool operator!=(Point2D const & p1, Point2D const & p2) { return !(p1==p2); }
  };

  struct Pose
  {
    double x, y, theta;
  };

  typedef std::vector<Point2D> Obstacle;

  struct ScanData
  {
    std::vector<RobotStatus::LidarData> data;
    Pose pose;
  };



  bool getObstacles(json const & jdata, std::vector<Obstacle>& obstacles);
  bool getObstacles(std::string const & filename, std::vector<Obstacle> & map);
  bool loadPath(std::string filename, G2lib::ClothoidList & cl);
  bool loadGoal(std::string filename, State2d & goal);


//#include "geometricAnalysis/GeometryTypes.hpp"

  const double pi = 3.1415926535897;
  /// @brief Function object to order points
  ///
  /// This function object is used in combination with standard algorithms (i.e., sort)
  /// to order a set of points.
  struct CMP_POINT {
    bool operator() (const cv::Point &p1, const cv::Point & p2) const {
      if (p1.x < p2.x)
    return true;
      if ((p1.x==p2.x)&&(p1.y < p2.y))
    return true;
      return false;
    }
  };



  template<typename valueType>
  std::valarray<double> VectorBetweenSegments(const cv::Vec<valueType, 4> & segm_1, const cv::Vec<valueType, 4> & segm_2) {

    std::valarray<double> p1 = {double(segm_1[0]), double(segm_1[1])};
    std::valarray<double> p2 = {double(segm_1[2]), double(segm_1[3])};
    std::valarray<double> p3 = {double(segm_2[0]), double(segm_2[1])};
    std::valarray<double> p4 = {double(segm_2[2]), double(segm_2[3])};
    std::valarray<double> u,v,w;
    // cv::Vec2d p3(segm_2.begin(), segm_2.begin()+1);
    // cv::Vec2d p4(segm_2.begin()+2, segm_2.begin()+3);
    // cv::Vec2d u, v, w;

    //u = p1 - p2
    u = p1-p2;
    //std::transform(p1.begin(), p1.end(), p2.begin(), u.begin(), std::minus<double>());
    //v=p3-p4
    v = p3-p4;
    //std::transform(p3.begin(), p3.end(), p4.begin(), v.begin(), std::minus<double>());
    w=p2-p4;
    //std::transform(p2.begin(), p2.end(), p4.begin(), w.begin(), std::minus<double>());

    // a = dot(u,u);
    double a = std::inner_product(std::begin(u), std::end(u), std::begin(u),0);
    // b = dot(u,v);
    double b = std::inner_product(std::begin(u), std::end(u), std::begin(v),0);
    // c = dot(v,v);
    double c = std::inner_product(std::begin(v), std::end(v), std::begin(v),0);
    // d = dot(u,w);
    double d = std::inner_product(std::begin(u), std::end(u), std::begin(w),0);
    // e = dot(v,w);
    double e = std::inner_product(std::begin(v), std::end(v), std::begin(w),0);

    double D = a*c - b*b;
    double StartD = D;
    double EndD = D;
    double TolD = 0.00000001;
    double StartN;
    double EndN;
    double sc;
    double tc;

    //Compute the line parameters of the two closest points
    if (D < TolD) {
      //Almost parallel lines: change the reference point for numeric
      //stability
      StartN = 0.0;
      StartD = 1.0;
      EndN = e;
      EndD = c;
    } else  {
      //Closest points for infinite lines
      StartN = (b*e - c*d);
      EndN = (a*e - b*d);
      if (StartN < 0.0) {   // sc < 0 => the s=0 edge is visible
    StartN = 0.0;
    EndN = e;
    EndD = c;
      } else
    if (StartN > StartD) { // sc > 1 => the s=1 edge is visible
      StartN = StartD;
      EndN = e + b;
      EndD = c;
    }
    }

    if (EndN < 0.0) {           // tc < 0 => the t=0 edge is visible
      EndN = 0.0;
      //Recompute sc for this edge
      if (-d < 0.0)
    StartN = 0.0;
      else if (-d > a)
    StartN = StartD;
      else {
    StartN = -d;
    StartD = a;
      }
    } else if (EndN > EndD) {       // tc > 1 => the t=1 edge is visible
      EndN = EndD;
      //Recompute sc for this edge
      if ((-d + b) < 0.0)
    StartN = 0;
      else if ((-d + b) > a)
    StartN = StartD;
      else {
    StartN = (-d + b);
    StartD = a;
      }
    }

  // Retrieve sc and tc
  if(fabs(StartN) < TolD)
    sc = 0.0;
  else
    sc = StartN/StartD;


  if(fabs(EndN) < TolD)
    tc = 0.0;
  else
    tc = EndN/EndD;

  w = w + (sc*u) - (tc*v);
  return w;
  }



  ///PROVISIONAL. Since we operate on a 2d space, we could do something much simpler!!!!
  template<typename valueType>
  double DistanceBetweenSegments(const cv::Vec<valueType, 4> & segm_1, const cv::Vec<valueType, 4> & segm_2) {
    std::valarray<double> w =  VectorBetweenSegments( segm_1, segm_2);

    return sqrt(std::inner_product(std::begin(w), std::end(w), std::begin(w),0));
  }

  template<typename valueType
>
  void DistanceAngleBetweenSegments(const cv::Vec<valueType, 4> & segm_1, const cv::Vec<valueType, 4> & segm_2, double & dist, double & angle ) {
    std::valarray<double> w =  VectorBetweenSegments( segm_1, segm_2);

    dist =  sqrt(std::inner_product(std::begin(w), std::end(w), std::begin(w),0));

    angle = (w.size() !=2) ? std::numeric_limits<double>::quiet_NaN() : atan2(w[1], w[0]);
  }



  //@NaN distance of point from line
  template<typename valType>
  double DistanceToLine(const cv::Point_<valType> & line_start, const cv::Point_<valType> & line_end, const cv::Point_<valType> & point)
  {
    double normalLength = std::hypot(line_end.x - line_start.x, line_end.y - line_start.y);
    double distance = (double)((point.x - line_start.x) * (line_end.y - line_start.y) - (point.y - line_start.y) * (line_end.x - line_start.x)) / normalLength;
    return fabs(distance);
  }

  template<typename valType>
  double DistToPoint( const cv::Point_<valType> & point_1, const cv::Point_<valType> & point_2) {
    // TRACE(point_1.x-point_2.x);

    // TRACE(point_1);
    // TRACE(point_2);
    // valType d= pow(point_1.x-point_2.x,2) + pow(point_1.y-point_2.y,2);
    // TRACE(d);
    // TRACE((point_1.x-point_2.x)*(point_1.x-point_2.x) + (point_1.y-point_2.y)*(point_1.y-point_2.y));

    // TRACE(sqrt((point_1.x-point_2.x)*(point_1.x-point_2.x) + (point_1.y-point_2.y)*(point_1.y-point_2.y)));
    return sqrt((point_1.x-point_2.x)*(point_1.x-point_2.x) + (point_1.y-point_2.y)*(point_1.y-point_2.y));
  };


  /// @brief connects two specified points with a line using the Bresenham algorithm
  inline void BresenhamConnect(cv::Point  p1, cv::Point  p2, std::vector<cv::Point> & points) {
    int xMin = std::min(p1.x, p2.x);
    int xMax = std::max(p1.x, p2.x);
    int yMin = std::min(p1.y, p2.y);
    int yMax = std::max(p1.y, p2.y);

    int yLen = yMax - yMin;
    int xLen = xMax - xMin;
    cv::Mat work = cv::Mat::zeros(yLen+1, xLen+1, CV_8U);

    cv::line(work, cv::Point(p1.x - xMin, p1.y-yMin), cv::Point(p2.x - xMin, p2.y-yMin), cv::Scalar::all(255), CV_AA);

    points.clear();
    findNonZero(work, points);
    std::for_each(points.begin(),
          points.end(),
          [&](cv::Point & p) {
            p.x += xMin;
            p.y += yMin;
          });

  }

  template<typename POINT>
  void rotateVector(std::vector<POINT> & vin, const cv::Mat_<double> & R, const cv::Mat_<double> & T) {
    for (int i = 0; i < vin.size(); i++) {
      cv::Mat_<double> work=cv::Mat(vin.at(i), false);
      work = R*work+T;
      work.copyTo(cv::Mat(vin.at(i), false));
    }
  }
  template<typename POINT>
  void rotatePoint(POINT & vin, const cv::Mat_<double> & R, const cv::Mat_<double> & T) {
    cv::Mat_<double> work=cv::Mat(vin, false);
    work = R*work+T;
    work.copyTo(cv::Mat(vin, false));
  }


  void extractInliers(const cv::Mat & image, std::vector<cv::Point> & validPoints, double xm, double ym, double xM, double yM, double distFromLine);

  template <typename T> int sgn(T val){
      return (T(0)<val) - (val < T(0));
  }

  inline double diffAngle(double beta, double alpha){
      //set alpha, beta between 0 and 2*pi
      while(fabs(beta)>2.0*M_PI){
          beta = beta - 2.0*M_PI*sgn(beta);
      }
      if(beta<0.0){
          beta = beta + 2.0*M_PI;
      }
      while(fabs(alpha)>2.0*M_PI){
          alpha = alpha - 2.0*M_PI*sgn(alpha);
      }
      if(alpha<0.0){
          alpha = alpha + 2.0*M_PI;
      }
      double difference = beta - alpha;
      if(difference>M_PI){
          difference = difference - 2.0*M_PI;
      }
      if(difference<-M_PI){
          difference = difference + 2.0*M_PI;
      }
      return difference;
  }

}




#endif
